# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'os.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.
import sys
from time import sleep

from PyQt5.QtCore import QTimer
from PyQt5.QtGui import QBrush, QColor
from PyQt5.QtWidgets import QApplication, QMainWindow, QMessageBox, QTableWidgetItem, QLayoutItem, QListWidgetItem

from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtWidgets import QApplication
from PyQt5.QtCore import QThread, pyqtSignal

import heapq

from PCB import PCB





class Ui_Form(object):

    #初始化参数开始
    cpu1Process = ""
    cpu1ProcessId = ""
    cpu1ProcessPriority = "0"
    cpu1ProcessTime = "0"
    cpu1ProcessPrevious = "0"
    cpu1ProcessMemory = "0"

    cpu2Process = ""
    cpu2ProcessId = ""
    cpu2ProcessPriority = "0"
    cpu2ProcessTime = "0"
    cpu2ProcessPrevious = "0"
    cpu2ProcessMemory = "0"

    maxPriorityProcess = ""
    maxPriorityProcessId = ""
    maxPriorityProcessTime = ""
    maxPriorityProcessPriority = "0"
    maxPriorityProcessPrevious = "0"
    maxPriorityProcessMemory = "0"

    secPriorityProcess = ""
    secPriorityProcessId = ""
    secPriorityProcessTime = ""
    secPriorityProcessPriority = "0"
    secPriorityProcessPrevious = "0"
    secPriorityProcessMemory = "0"

    b1PriorityProcess = ""
    b1PriorityProcessId = ""
    b1PriorityProcessTime = ""
    b1PriorityProcessPriority = "0"
    b1PriorityProcessPrevious = "0"
    b1PriorityProcessMemory = "0"

    b2PriorityProcess = ""
    b2PriorityProcessId = ""
    b2PriorityProcessTime = ""
    b2PriorityProcessPriority = "0"
    b2PriorityProcessPrevious = "0"
    b2PriorityProcessMemory = "0"

    secpri = ""

    number = 1   #用来记录进程编号

    # #定义队列
    # reserveLm = [] #后备队列
    # readyLm = []  #就绪队列
    # waitingLm = []  #挂起队列
    # blockedLm = []  #阻塞队列
    # finishLm = []  #完成队列
    waiting_to_Ready_list = []

    #初始化内存数组
    record = [0] * 100
    #操作系统中所使用的内存,初始值为0
    totalmemory = 0

    #内存表的地址状态
    memory = []


    #道数
    dao = 3

    #现在的道数
    nowdao = 0

    def setupUi(self, Form):
        self.Form = Form
        Form.setObjectName("Form")
        Form.resize(1398, 696)
        self.label = QtWidgets.QLabel(Form)
        self.label.setGeometry(QtCore.QRect(10, 30, 58, 16))
        self.label.setObjectName("label")
        self.label_2 = QtWidgets.QLabel(Form)
        self.label_2.setGeometry(QtCore.QRect(190, 30, 58, 16))
        self.label_2.setObjectName("label_2")
        self.label_3 = QtWidgets.QLabel(Form)
        self.label_3.setGeometry(QtCore.QRect(370, 30, 58, 16))
        self.label_3.setObjectName("label_3")
        self.label_4 = QtWidgets.QLabel(Form)
        self.label_4.setGeometry(QtCore.QRect(570, 30, 58, 16))
        self.label_4.setObjectName("label_4")
        self.add_btn = QtWidgets.QPushButton(Form)
        self.add_btn.setGeometry(QtCore.QRect(810, 20, 201, 41))
        self.add_btn.setObjectName("add_btn")
        #TODO：测试按钮
        self.test_btn = QtWidgets.QPushButton(Form)
        self.test_btn.setGeometry(QtCore.QRect(1100, 20, 201, 41))
        self.test_btn.setObjectName("test_btn")
        self.listWidget_reserve = QtWidgets.QListWidget(Form)
        self.listWidget_reserve.setGeometry(QtCore.QRect(20, 140, 141, 291))
        self.listWidget_reserve.setObjectName("listWidget_reserve")
        self.textEdit_time = QtWidgets.QTextEdit(Form)
        self.textEdit_time.setGeometry(QtCore.QRect(80, 30, 91, 21))
        self.textEdit_time.setObjectName("textEdit_time")
        # self.textEdit_pre = QtWidgets.QTextEdit(Form)
        # self.textEdit_pre.setGeometry(QtCore.QRect(450, 30, 91, 21))
        # self.textEdit_pre.setObjectName("textEdit_pre")
        self.textEdit_size = QtWidgets.QTextEdit(Form)
        self.textEdit_size.setGeometry(QtCore.QRect(660, 30, 91, 21))
        self.textEdit_size.setObjectName("textEdit_size")
        #CPU1
        self.label_CPU1 = QtWidgets.QLabel(Form)
        self.label_CPU1.setGeometry(QtCore.QRect(1000, 100, 58, 16))
        self.label_CPU1.setObjectName("label_CPU1")
        self.textEdit_CPU1 = QtWidgets.QTextEdit(Form)
        self.textEdit_CPU1.setGeometry(QtCore.QRect(1000, 150,140, 50))
        self.textEdit_CPU1.setObjectName("textEdit_CPU1")
        # CPU2
        self.label_CPU2 = QtWidgets.QLabel(Form)
        self.label_CPU2.setGeometry(QtCore.QRect(1000, 300, 58, 16))
        self.label_CPU2.setObjectName("label_CPU2")
        self.textEdit_CPU2 = QtWidgets.QTextEdit(Form)
        self.textEdit_CPU2.setGeometry(QtCore.QRect(1000, 350, 140, 50))
        self.textEdit_CPU2.setObjectName("textEdit_CPU2")

        self.tableWidget_2 = QtWidgets.QTableWidget(Form)
        self.tableWidget_2.setGeometry(QtCore.QRect(1150, 70, 231, 621))
        self.tableWidget_2.setRowCount(40)
        self.tableWidget_2.setObjectName("tableWidget_2")
        self.tableWidget_2.setColumnCount(2)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_2.setHorizontalHeaderItem(0, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_2.setHorizontalHeaderItem(1, item)
        self.label_5 = QtWidgets.QLabel(Form)
        self.label_5.setGeometry(QtCore.QRect(30, 100, 58, 16))
        self.label_5.setObjectName("label_5")
        self.label_6 = QtWidgets.QLabel(Form)
        self.label_6.setGeometry(QtCore.QRect(230, 100, 58, 16))
        self.label_6.setObjectName("label_6")
        self.listWidget_ready = QtWidgets.QListWidget(Form)
        self.listWidget_ready.setGeometry(QtCore.QRect(220, 140, 141, 461))
        self.listWidget_ready.setObjectName("listWidget_ready")
        self.label_7 = QtWidgets.QLabel(Form)
        self.label_7.setGeometry(QtCore.QRect(430, 100, 58, 16))
        self.label_7.setObjectName("label_7")
        self.listWidget_suspend = QtWidgets.QListWidget(Form)
        self.listWidget_suspend.setGeometry(QtCore.QRect(420, 140, 141, 291))
        self.listWidget_suspend.setObjectName("listWidget_suspend")
        self.label_8 = QtWidgets.QLabel(Form)
        self.label_8.setGeometry(QtCore.QRect(640, 100, 58, 16))
        self.label_8.setObjectName("label_8")
        self.listWidget_finish = QtWidgets.QListWidget(Form)
        self.listWidget_finish.setGeometry(QtCore.QRect(820, 140, 141, 291))
        self.listWidget_finish.setObjectName("listWidget_finish")
        self.label_9 = QtWidgets.QLabel(Form)
        self.label_9.setGeometry(QtCore.QRect(820, 100, 58, 16))
        self.label_9.setObjectName("label_9")
        self.re_to_rd = QtWidgets.QLabel(Form)
        self.re_to_rd.setGeometry(QtCore.QRect(170, 240, 58, 16))
        self.re_to_rd.setObjectName("re_to_rd")
        self.rd_to_sp = QtWidgets.QLabel(Form)
        self.rd_to_sp.setGeometry(QtCore.QRect(370, 240, 58, 16))
        self.rd_to_sp.setObjectName("rd_to_sp")
        self.sp_rd = QtWidgets.QLabel(Form)
        self.sp_rd.setGeometry(QtCore.QRect(370, 280, 58, 16))
        self.sp_rd.setObjectName("sp_rd")
        self.listWidget_waiting = QtWidgets.QListWidget(Form)
        self.listWidget_waiting.setGeometry(QtCore.QRect(620, 140, 141, 461))
        self.listWidget_waiting.setObjectName("listWidget_waiting")
        self.rd_to_wt = QtWidgets.QLabel(Form)
        self.rd_to_wt.setGeometry(QtCore.QRect(370, 490, 241, 16))
        self.rd_to_wt.setObjectName("rd_to_wt")
        self.wt_to_rd = QtWidgets.QLabel(Form)
        self.wt_to_rd.setGeometry(QtCore.QRect(370, 540, 241, 16))
        self.wt_to_rd.setObjectName("wt_to_rd")
        self.suspend_btn = QtWidgets.QPushButton(Form)
        self.suspend_btn.setGeometry(QtCore.QRect(230, 620, 112, 32))
        self.suspend_btn.setObjectName("suspend_btn")
        self.cancel_btn = QtWidgets.QPushButton(Form)
        self.cancel_btn.setGeometry(QtCore.QRect(430, 620, 112, 32))
        self.cancel_btn.setObjectName("cancel_btn")
        self.comboBox_pro = QtWidgets.QComboBox(Form)
        self.comboBox_pro.setGeometry(QtCore.QRect(250, 20, 91, 32))
        self.comboBox_pro.setObjectName("comboBox_pro")
        self.comboBox_pro.addItem("")
        self.comboBox_pro.addItem("")
        self.comboBox_pro.addItem("")
        self.comboBox_pro.addItem("")
        self.comboBox_pro.addItem("")
        self.comboBox_pro.addItem("")
        self.comboBox_pro.addItem("")
        self.comboBox_pre = QtWidgets.QComboBox(Form)
        self.comboBox_pre.setGeometry(QtCore.QRect(450, 30, 91, 21))
        self.comboBox_pre.setObjectName("comboBox_pre")

        # self.tableWidget_1 = QtWidgets.QTableWidget(Form)
        # self.tableWidget_1.setGeometry(QtCore.QRect(800, 140, 331, 321))
        # self.tableWidget_1.setRowCount(10)
        # self.tableWidget_1.setObjectName("tableWidget_1")
        # self.tableWidget_1.setColumnCount(3)
        # item = QtWidgets.QTableWidgetItem()
        # self.tableWidget_1.setHorizontalHeaderItem(0, item)
        # item = QtWidgets.QTableWidgetItem()
        # self.tableWidget_1.setHorizontalHeaderItem(1, item)
        # item = QtWidgets.QTableWidgetItem()
        # self.tableWidget_1.setHorizontalHeaderItem(2, item)
        self.label_15 = QtWidgets.QLabel(Form)
        self.label_15.setGeometry(QtCore.QRect(880, 100, 221, 31))
        font = QtGui.QFont()
        font.setPointSize(18)
        self.label_15.setFont(font)
        self.label_15.setObjectName("label_15")
        self.label.raise_()
        self.label_2.raise_()
        self.label_3.raise_()
        self.label_4.raise_()
        self.add_btn.raise_()
        #TODO:测试按钮
        self.test_btn.raise_()
        self.listWidget_reserve.raise_()
        self.textEdit_time.raise_()
        # self.textEdit_pre.raise_()
        self.textEdit_size.raise_()
        #CPU1和CPU2
        self.textEdit_CPU1.raise_()
        self.textEdit_CPU2.raise_()
        self.tableWidget_2.raise_()
        self.label_5.raise_()
        self.label_6.raise_()
        self.label_7.raise_()
        self.listWidget_suspend.raise_()
        self.label_8.raise_()
        self.label_9.raise_()
        self.listWidget_ready.raise_()
        self.re_to_rd.raise_()
        self.rd_to_sp.raise_()
        self.sp_rd.raise_()
        self.listWidget_waiting.raise_()
        self.rd_to_wt.raise_()
        self.wt_to_rd.raise_()
        self.suspend_btn.raise_()
        self.cancel_btn.raise_()
        self.cancel_btn.clicked.connect(self.unsuspendPCB)
        self.comboBox_pro.raise_()
        self.comboBox_pre.raise_()
        # self.tableWidget_1.raise_()
        # self.label_15.raise_()
        self.retranslateUi(Form)
        QtCore.QMetaObject.connectSlotsByName(Form)

    def retranslateUi(self, Form):
        _translate = QtCore.QCoreApplication.translate
        Form.setWindowTitle(_translate("Form", "Form"))
        self.label.setText(_translate("Form", "运行时间："))
        self.label_2.setText(_translate("Form", "优先级："))
        self.label_3.setText(_translate("Form", "前驱进程："))
        self.label_4.setText(_translate("Form", "所占大小："))
        self.add_btn.setText(_translate("Form", "添加进程"))
        self.add_btn.clicked.connect(self.addPCB)
        self.test_btn.setText(_translate("Form", "启动按钮"))
        self.test_btn.clicked.connect(self.test)
        item = self.tableWidget_2.horizontalHeaderItem(0)
        item.setText(_translate("Form", "内存地址"))
        item = self.tableWidget_2.horizontalHeaderItem(1)
        item.setText(_translate("Form", "内存状态"))
        self.label_5.setText(_translate("Form", "后备队列"))
        self.label_6.setText(_translate("Form", "就绪队列"))
        self.label_7.setText(_translate("Form", "挂起队列"))
        self.label_8.setText(_translate("Form", "阻塞队列"))
        self.label_9.setText(_translate("Form", "完成队列"))
        self.label_CPU1.setText(_translate("Form", "CPU1："))
        self.label_CPU2.setText(_translate("Form", "CPU2："))
        self.re_to_rd.setText(_translate("Form", "----->"))
        self.rd_to_sp.setText(_translate("Form", "----->"))
        self.sp_rd.setText(_translate("Form", "<-----"))
        self.rd_to_wt.setText(_translate("Form", "-------------------------------------->"))
        self.wt_to_rd.setText(_translate("Form", "<--------------------------------------"))
        self.suspend_btn.setText(_translate("Form", "挂起"))
        self.suspend_btn.clicked.connect(self.suspendPCB)
        self.cancel_btn.setText(_translate("Form", "解挂"))
        self.comboBox_pro.setItemText(0, _translate("Form", "1"))
        self.comboBox_pro.setItemText(1, _translate("Form", "2"))
        self.comboBox_pro.setItemText(2, _translate("Form", "3"))
        self.comboBox_pro.setItemText(3, _translate("Form", "4"))
        self.comboBox_pro.setItemText(4, _translate("Form", "5"))
        self.comboBox_pro.setItemText(5, _translate("Form", "6"))
        self.comboBox_pro.setItemText(6, _translate("Form", "7"))
        self.comboBox_pre.addItem("0")
        # self.textEdit_pre.setText("0")
        # item = self.tableWidget_1.horizontalHeaderItem(0)
        # item.setText(_translate("Form", "起地址"))
        # item = self.tableWidget_1.horizontalHeaderItem(1)
        # item.setText(_translate("Form", "长度"))
        # item = self.tableWidget_1.horizontalHeaderItem(2)
        # item.setText(_translate("Form", "状态"))
        # self.label_15.setText(_translate("Form", "          内存分区表"))
        #配置内存分区表,则已被使用，否则等于到空闲段的末地址 * /
        for i in range(40):
            # self.tableWidget.item()
            self.tableWidget_2.setItem(i, 0,QTableWidgetItem(str(i)))
            item = QTableWidgetItem()
            item.setText("未使用")
            item.setBackground(QBrush(QColor(211,211,211)))
            self.memory.append(item)
            self.tableWidget_2.setItem(i, 1, item)
        #配置内存分区表的颜色
        self.memory[5].setBackground(QBrush(QColor(250,0,0)))
        self.memory[10].setBackground(QBrush(QColor(250,0,0)))
        self.memory[25].setBackground(QBrush(QColor(250,0,0)))
        self.memory[26].setBackground(QBrush(QColor(250, 0, 0)))
        self.memory[5].setText("OS")
        self.memory[10].setText("OS")
        self.memory[25].setText("OS")
        self.memory[26].setText("OS")

    '''
        添加进程函数模块
        '''

    def addPCB(self):

        if (self.textEdit_time.toPlainText() == "" and
                self.previousCb.toPlainText() == "" and
                self.textEdit_size.toPlainText() == ""):
            QMessageBox.warning(self.Form,
                                "错误",
                                "输入错误！",
                                QMessageBox.Yes | QMessageBox.No)
            return

        if self.comboBox_pre.currentText() ==None :
            previous = "0"
        else:
            previous = self.comboBox_pre.currentText()

        pid = str(self.number)
        time = self.textEdit_time.toPlainText()
        priority = self.comboBox_pro.currentText()

        if (previous == pid):
            QMessageBox.warning(self.Form,
                                "错误",
                                "不能把自己设为前驱！",
                                QMessageBox.Yes | QMessageBox.No)
            return
        memorysize = self.textEdit_size.toPlainText()
        newPcb = PCB(pid, time, priority, previous, memorysize)
        self.listWidget_reserve.addItem(str(newPcb))

        self.comboBox_pre.addItem(str(self.number))

        # 让进程编号加一
        self.number = self.number + 1

        print(self.listWidget_ready.count())


    '''
    挂起进程函数模块
    '''

    def suspendPCB(self):
        if (self.listWidget_ready.currentItem() == None):
            QMessageBox.warning(self.Form,
                                "错误",
                                "请选中一个就绪队列中的进程！",
                                QMessageBox.Yes | QMessageBox.No)
            return
        # 1.获取当前选中的进程
        suspendPCB = self.listWidget_ready.currentItem()
        self.listWidget_ready.takeItem(self.listWidget_ready.row(suspendPCB))
        self.listWidget_suspend.addItem(suspendPCB)
        suspendPCB_text = suspendPCB.text()
        # self.memory_recovery(suspendPCB_text.split(","))
        # sleep(1500)

    '''
    解挂进程函数模块
    '''

    def unsuspendPCB(self):
        if (self.listWidget_suspend.currentItem() == None):
            QMessageBox.warning(self.Form,
                                "错误",
                                "请选中一个挂起队列中的进程！",
                                QMessageBox.Yes | QMessageBox.No)
            return
        unsuspendProcess = self.listWidget_suspend.currentItem()
        self.waiting_to_Ready_list.append(unsuspendProcess)
        unsuspendPCB_text = str(unsuspendProcess).split(",")
        # 重新申请内存释放
        # canput = self.memory_alloc(unsuspendPCB_text)
        print("解挂成功")

        # if (bool(1 - canput)):
        #     # 如果申请失败，弹出提示框
        #     QMessageBox.warning(self.Form,
        #                         "错误",
        #                         "没有足够的内存",
        #                         QMessageBox.Yes | QMessageBox.No)
        # else:

    def test(self):

        #启动操作系统
        self.mythread = MyThread()  # 实例化自己建立的任务线程类
        self.mythread.initUI(self,self.record,self.memory,self.waiting_to_Ready_list,self.nowdao,self.dao)

        self.mythread.signal_list_reserve_add.connect(self.callback_listweight_reserve_add)  # 设置任务线程发射信号触发的函数
        self.mythread.signal_list_reserve_del.connect(self.callback_listweight_reserve_del)  # 设置任务线程发射信号触发的函数

        self.mythread.signal_list_ready_add.connect(self.callback_listweight_ready_add)  # 设置任务线程发射信号触发的函数
        self.mythread.signal_list_ready_del.connect(self.callback_listweight_ready_del)  # 设置任务线程发射信号触发的函数

        self.mythread.signal_list_suspend_add.connect(self.callback_listweight_suspend_add)  # 设置任务线程发射信号触发的函数
        self.mythread.signal_list_suspend_del.connect(self.callback_listweight_suspend_del)  # 设置任务线程发射信号触发的函数

        self.mythread.signal_list_suspend_add.connect(self.callback_listweight_suspend_add)  # 设置任务线程发射信号触发的函数
        self.mythread.signal_list_suspend_del.connect(self.callback_listweight_suspend_del)  # 设置任务线程发射信号触发的函数

        self.mythread.signal_list_waiting_add.connect(self.callback_listweight_waiting_add)  # 设置任务线程发射信号触发的函数
        self.mythread.signal_list_waiting_del.connect(self.callback_listweight_waiting_del)  # 设置任务线程发射信号触发的函数

        self.mythread.signal_list_finish_add.connect(self.callback_listweight_finish_add)  # 设置任务线程发射信号触发的函数
        self.mythread.signal_list_finish_del.connect(self.callback_listweight_finish_del)  # 设置任务线程发射信号触发的函数

        self.mythread.signal_list_memory_setBackground.connect(self.callback_list_memory_setBackground)  # 设置任务线程发射信号触发的函数
        self.mythread.signal_list_memory_setText.connect(self.callback_list_memory_setText)  # 设置任务线程发射信号触发的函数

        self.mythread.signal_CPU1_setText.connect(self.callback_CPU1_setText)  # 设置任务线程发射信号触发的函数
        self.mythread.signal_CPU2_setText.connect(self.callback_CPU2_setText)  # 设置任务线程发射信号触发的函数

        self.mythread.signal_CPU1_setStyleSheet.connect(self.callback_CPU1_setStyleSheet)  # 设置任务线程发射信号触发的函数
        self.mythread.signal_CPU2_setStyleSheet.connect(self.callback_CPU2_setStyleSheet)  # 设置任务线程发射信号触发的函数

        self.mythread.signal_list_ready_add_fortext.connect(self.callback_listweight_ready_add_fortext)
        self.mythread.signal_list_finish_add_fortext.connect(self.callback_listweight_finish_add_fortext)

        self.mythread.start()  # 启动任务线程

    #TODO:槽信号
    def callback_listweight_reserve_add(self,item):
        print("callback_listweight_reserve_add收到消息了")
        # 接收到新号，重新绘制主界面
        self.listWidget_reserve.addItem(item)
    def callback_listweight_reserve_del(self,item):
        print("callback_listweight_reserve_del收到消息了")
        # 接收到新号，重新绘制主界面
        self.listWidget_reserve.takeItem(self.listWidget_reserve.row(item))
    def callback_listweight_ready_add(self,item):
        print("callback_listweight_ready_add收到消息了")
        # 接收到新号，重新绘制主界面
        self.listWidget_ready.addItem(item)
    def callback_listweight_ready_add_fortext(self,str):
        print("callback_listweight_ready_add_fortext收到消息了")
        # 接收到新号，重新绘制主界面
        self.listWidget_ready.addItem(str)
    def callback_listweight_ready_del(self,item):
        print("callback_listweight_ready_del收到消息了")
        # 接收到新号，重新绘制主界面
        self.listWidget_ready.takeItem(self.listWidget_ready.row(item))
    def callback_listweight_suspend_add(self,item):
        print("callback_listweight_suspend_add收到消息了")
        # 接收到新号，重新绘制主界面
        self.listWidget_suspend.addItem(item.text())
    def callback_listweight_suspend_del(self,item):
        print("callback_listweight_suspend_del收到消息了")
        # 接收到新号，重新绘制主界面
        self.listWidget_suspend.takeItem(self.listWidget_suspend.row(item))
    def callback_listweight_finish_add(self,item):
        print("callback_listweight_finish_add收到消息了")
        # 接收到新号，重新绘制主界面
        self.listWidget_finish.addItem(item)
    def callback_listweight_finish_add_fortext(self,str):
        print("callback_listweight_finish_add_fortext收到消息了")
        # 接收到新号，重新绘制主界面
        self.listWidget_finish.addItem(str)
    def callback_listweight_finish_del(self,item):
        # 接收到新号，重新绘制主界面
        print("callback_listweight_finish_del收到消息了")
        self.listWidget_finish.takeItem(self.listWidget_finish.row(item))
    def callback_listweight_waiting_add(self,item):
        print("callback_listweight_waiting_add收到消息了")
        # 接收到新号，重新绘制主界面
        self.listWidget_waiting.addItem(item.text())
    def callback_listweight_waiting_del(self,item):
        print("callback_listweight_waiting_del收到消息了")
        # 接收到新号，重新绘制主界面
        self.listWidget_waiting.takeItem(self.listWidget_waiting.row(item))
    def callback_CPU1_setText(self,str):
        print("callback_CPU1_setText收到消息了")
        # 接收到新号，重新绘制主界面
        self.textEdit_CPU1.setText(str)
    def callback_CPU2_setText(self,str):
        print("callback_CPU2_setText收到消息了")
        # 接收到新号，重新绘制主界面
        self.textEdit_CPU2.setText(str)
    def callback_CPU1_setStyleSheet(self,str):
        print("callback_CPU1_setStyleSheet收到消息了")
        # 接收到新号，重新绘制主界面
        self.textEdit_CPU1.setStyleSheet(str)
    def callback_CPU2_setStyleSheet(self,str):
        print("callback_CPU2_setStyleSheet收到消息了")
        # 接收到新号，重新绘制主界面
        self.textEdit_CPU2.setStyleSheet(str)
    def callback_list_memory_setBackground(self,QBrush,index):
        print("callback_list_memory_setBackground收到消息了")
        # 接收到新号，重新绘制主界面
        self.memory[index].setBackground(QBrush)
    def callback_list_memory_setText(self,str,index):
        print("callback_list_memory_setText收到消息了")
        self.memory[index].setText(str)
        # 接收到新号，重新绘制主界面





class MyThread(QThread):  # 建立一个任务线程类
    signal_list_reserve_add = pyqtSignal(QListWidgetItem)  # 设置触发信号传递的参数数据类型,这里是字符串
    signal_list_reserve_del = pyqtSignal(QListWidgetItem)  # 设置触发信号传递的参数数据类型,这里是字符串

    signal_list_ready_add = pyqtSignal(QListWidgetItem)  # 设置触发信号传递的参数数据类型,这里是字符串
    signal_list_ready_del = pyqtSignal(QListWidgetItem)  # 设置触发信号传递的参数数据类型,这里是字符串

    signal_list_suspend_add = pyqtSignal(QListWidgetItem)  # 设置触发信号传递的参数数据类型,这里是字符串
    signal_list_suspend_del = pyqtSignal(QListWidgetItem)  # 设置触发信号传递的参数数据类型,这里是字符串

    signal_list_waiting_add = pyqtSignal(QListWidgetItem)  # 设置触发信号传递的参数数据类型,这里是字符串
    signal_list_waiting_del = pyqtSignal(QListWidgetItem)  # 设置触发信号传递的参数数据类型,这里是字符串

    signal_list_finish_add = pyqtSignal(QListWidgetItem)  # 设置触发信号传递的参数数据类型,这里是字符串
    signal_list_finish_del = pyqtSignal(QListWidgetItem)  # 设置触发信号传递的参数数据类型,这里是字符串

    signal_list_memory_setBackground = pyqtSignal(QBrush,int)  # 设置触发信号传递的参数数据类型,这里是字符串
    signal_list_memory_setText = pyqtSignal(str,int)  # 设置触发信号传递的参数数据类型,这里是字符串

    signal_CPU1_setText = pyqtSignal(str)  # 设置触发信号传递的参数数据类型,这里是字符串
    signal_CPU2_setText = pyqtSignal(str)  # 设置触发信号传递的参数数据类型,这里是字符串
    signal_CPU1_setStyleSheet = pyqtSignal(str)  # 设置触发信号传递的参数数据类型,这里是字符串
    signal_CPU2_setStyleSheet = pyqtSignal(str)  # 设置触发信号传递的参数数据类型,这里是字符串

    signal_list_ready_add_fortext = pyqtSignal(str)  # 设置触发信号传递的参数数据类型,这里是字符串
    signal_list_finish_add_fortext = pyqtSignal(str)  # 设置触发信号传递的参数数据类型,这里是字符串

    signal_time = pyqtSignal(int)
    # 初始化CPU1和CPU2
    cpu1Process = []
    cpu1Process_text = ""
    cpu2Process = []
    cpu2Process_text = ""

    memory = []

    waiting_to_Ready_list = []

    def __init__(self):
        super(MyThread, self).__init__()


    def initUI(self,Form,record,momory,waiting_to_Ready_list,nowdao,dao):
        self.nowdao = nowdao
        self.dao = dao
        self.record = record
        self.memory = momory
        self.waiting_to_Ready_list = waiting_to_Ready_list
        self.listWidget_ready = Form.listWidget_ready
        self.listWidget_reserve = Form.listWidget_reserve
        self.listWidget_waiting = Form.listWidget_waiting
        self.listWidget_finish = Form.listWidget_finish
        self.listWidget_suspend = Form.listWidget_suspend
        self.totalmemory = Form.totalmemory
        print(self.waiting_to_Ready_list)
        print(self.listWidget_ready)
        print(self.listWidget_reserve)
        print(self.listWidget_waiting)
        print(self.listWidget_suspend)
        print(self.listWidget_finish)
        print(self.totalmemory)

    def run(self):  # 在启动线程后任务从这个函数里面开始执行
        print("进程启动")
        self.OSmain()

    def OSmain(self):
        # # 设置定时器
        # self.time = QTimer()
        # self.time.timeout.connect(self.stopTimer)

        #定义槽信号
        # 配置内存分区表, 则已被使用，否则等于到空闲段的末地址
        self.record[0] = 4
        self.record[5] = -1
        self.record[6] = 9
        self.record[10] = -1
        self.record[11] = 24
        self.record[25] = -1
        self.record[26] = -1
        self.record[27] = 39

        pd123 = 0
        pd = []
        while(1):
            print("进来了")
            self.sleep(1)

            # if(self.listWidget_reserve.item(0)!=None):
            #     print(self.listWidget_reserve.item(0).text())
            # else:
            #     print("没有东西")

            #初始化CPU1和CPU2
            self.cpu1Process = []
            self.cpu1Process_text = ""
            self.cpu2Process = []
            self.cpu2Process_text = ""
            havepre1 = False
            havepre2 = False
            '''
            就绪队列准备阶段：
            1。首先判断挂起队列中有没有让用户钦点后等待进入就绪队列的
            2。再来看下有没有因为前驱节点完成了的还在阻塞队列里等着进入就绪队列里的
            3。判断后备队列进程是否能进就绪队列
            '''
            # 1.首先判断挂起队列中有没有让用户钦点后等待进入就绪队列的
            while (len(self.waiting_to_Ready_list)!= 0):
                PCB1 = self.waiting_to_Ready_list.pop()
                self.signal_list_ready_add_fortext.emit(PCB1.text())
                # self.listWidget_ready.addItem(PCB_text.text())
                #TODO:添加颜色
                # self.wt_to_rd.setStyleSheet("color:red")
                # self.wt_to_rd.setStyleSheet("color:break")
                self.signal_list_suspend_del.emit(PCB1)
                # self.listWidget_suspend.takeItem(self.listWidget_suspend.row(PCB_text))

            # 2.前驱节点完成后把相应的进程从阻塞队列加入到就绪队列中
            if (self.listWidget_waiting.item(0)!=None and self.listWidget_finish.item(0)!=None) :
                waitingListnum =self.listWidget_waiting.count()
                i = waitingListnum-1
                while(i>=0):
                    blockedInfo = self.listWidget_waiting.item(i).text().split(",")  # 阻塞进程信息
                    finishListnum = self.listWidget_finish.count()
                    j = finishListnum - 1
                    while(j>=0):
                        finishInfo = self.listWidget_finish.item(j).text().split(",")  # 完成进程信息
                        if (int(blockedInfo[3]) == int(finishInfo[0])):
                            tempPCB = PCB(blockedInfo[0],blockedInfo[1],blockedInfo[2],blockedInfo[3],blockedInfo[4])
                            self.signal_list_ready_add_fortext.emit(self.listWidget_waiting.item(i).text())
                            # self.listWidget_ready.addItem(str(tempPCB))

                            # self.listWidget_waiting.takeItem(self.listWidget_waiting.row(str(tempPCB)))
                            self.signal_list_waiting_del.emit(self.listWidget_waiting.item(i))
                            # TODO：修改颜色
                            # self.wt_to_rd.setStyleSheet("color:red")
                            self.sleep(1)
                            # self.wt_to_rd.setStyleSheet("color:break")

                        j=j-1
                    i = i-1
            #3.采用首次匹配算法判断后备队列进程能否进就绪队列
            while (self.listWidget_reserve.item(0)!=None and (self.totalmemory <= len(self.memory) - 4)):
                a = self.listWidget_reserve.item(0).text().split(",")
                self.totalmemory += int(a[4])
                if (self.nowdao == self.dao):
                    break
                    return False
                if (self.totalmemory <= len(self.memory) -4) :
                    # 首次适应算法
                    x = 0
                    while(x < len(self.memory)):
                        if ((self.record[x]-x+1) >= int(a[4])):
                            print("进程放入")
                            # 该进程进就绪队列
                            self.signal_list_ready_add_fortext.emit(self.listWidget_reserve.item(0).text())
                            # self.listWidget_ready.addItem(self.listWidget_reserve.item(0).text())
                            #TODO:配置颜色
                            # self.re_to_rd.setStyleSheet("color:red")
                            self.signal_list_reserve_del.emit(self.listWidget_reserve.item(0))
                            #增加道数
                            self.nowdao = self.nowdao+1

                            # self.listWidget_reserve.takeItem(0)
                            temp=self.record[x]
                            y = x
                            while(y<x+int(a[4])):
                                #重新绘制内存表
                                self.signal_list_memory_setBackground.emit(QBrush(QColor(250,0,0)),y)
                                # self.signal_list_memory_setBackground()
                                # self.memory[y].setBackground(QBrush(QColor(250,0,0)))
                                # self.memory[y].setText(a[0])
                                self.signal_list_memory_setText.emit(a[0],y)
                                self.record[y] = -1
                                y=y+1
                            if ((x + int(a[4])) <= 39) :
                                self.record[x+int(a[4])] = temp
                            break
                        x = x+1

                    self.sleep(1)
                    #TODO：配置烟色
                    # self.re_to_rd.setStyleSheet("color:break")

            '''
            就绪队列的准备工作完成
            '''

            '''
            开始使用就绪队列中的进程来进行调度
            1。先筛选出前驱节点为完成的需要进入阻塞队列里面的进程,将这些进程筛选出来之后，直接进行TOP2的比较筛选出能进入CPU1和CPU2的进程
            2。如果当前就绪队列里面的进程数量是两个一下，就不用进行比较了，直接放入CPU1和CPU2中就行了
            3。就绪队列中的进程按优先级排序，找出优先级TOP2的进入CPU1运行和CPU2运行
            '''
            #开始进行筛选要进入阻塞队列里面的进程
            i = 0
            while(i<self.listWidget_ready.count()):
                currentPCB_Info = self.listWidget_ready.item(i).text().split(",")
                if(currentPCB_Info[3]!="0"):
                    #说明是有前驱节点的，再来看看他前驱节点是不是为完成，如果未完成那就需要放入阻塞队列中
                    j = 0
                    block = True   #现设置需要阻塞，遍历一遍看看能不能吧这个标志改成不需要阻塞
                    while(j<self.listWidget_finish.count()):
                        finishPCB_Info = self.listWidget_finish.item(j).text().split(",")
                        if(currentPCB_Info[3]==finishPCB_Info[0]):
                            #说明他的前驱节点已经完成，就不需要阻塞该进程
                            block= False
                            break
                        j = j+1
                    if(block):
                        #说明遍历了一遍完成队列，该前驱节点还没有完成，那就让他进入阻塞队列中
                        #1。添加到阻塞队列中
                        self.signal_list_waiting_add.emit(self.listWidget_ready.item(i))
                        # self.listWidget_waiting.addItem(self.listWidget_ready.item(i))
                        #2。删除就绪队列中的该进程
                        self.signal_list_ready_del.emit(self.listWidget_ready.item(i))
                        # self.listWidget_ready.takeItem(i)
                i = i+1
            #筛选完毕，开始准备进入CPU运行
            if(self.listWidget_ready.count()!=0):
                if (self.listWidget_ready.count() == 1):
                    self.cpu1Process_text = self.listWidget_ready.item(0).text()
                    self.cpu1Process = self.listWidget_ready.item(0)
                elif (self.listWidget_ready.count() == 2):
                    self.cpu1Process_text = self.listWidget_ready.item(0).text()
                    self.cpu1Process = self.listWidget_ready.item(0)
                    self.cpu2Process_text = self.listWidget_ready.item(1).text()
                    self.cpu2Process = self.listWidget_ready.item(1)
                else:
                    TOP2list = []
                    # 构建比较优先级的数组
                    for index in range(self.listWidget_ready.count()):
                        TOP2list.append(int(self.listWidget_ready.item(index).text().split(",")[2]))
                    # 利用heapq直接将TOP2的优先级的index索引下标获取到，然后直接赋给CPU1和CPU2
                    TOP2list_pro_index = list(map(TOP2list.index, heapq.nlargest(1, TOP2list)))
                    # print("筛选出来的"+str(TOP2list_pro_index))
                    self.cpu1Process = self.listWidget_ready.item(TOP2list_pro_index[0])
                    self.cpu1Process_text = self.listWidget_ready.item(TOP2list_pro_index[0]).text()
                    #吧第一大的去掉比较
                    TOP2list[TOP2list_pro_index[0]] = 0
                    TOP2list_pro_index = list(map(TOP2list.index, heapq.nlargest(1, TOP2list)))
                    # print("筛选出来的" + str(TOP2list_pro_index))
                    self.cpu2Process = self.listWidget_ready.item(TOP2list_pro_index[0])
                    self.cpu2Process_text = self.listWidget_ready.item(TOP2list_pro_index[0]).text()

            #CPU1  部分

            if(self.cpu1Process_text!=""):
                #删除就绪队列中要往CPU1中运行的item
                self.signal_list_ready_del.emit(self.cpu1Process)
                # self.listWidget_ready.takeItem(self.listWidget_ready.row(self.cpu1Process_text))
                #该进程进入CPU1中运行
                # self.textEdit_CPU1.setStyleSheet("backgroud:red")
                self.signal_CPU1_setStyleSheet.emit("background:red")
                # self.textEdit_CPU1.setText("进程号："+self.cpu1Process_text.split(",")[0])
                self.signal_CPU1_setText.emit("进程号："+self.cpu1Process_text.split(",")[0])

            # CPU2   部分
            if (self.cpu2Process_text != ""):
                # 该进程进入CPU2中运行
                # self.listWidget_ready.takeItem(self.listWidget_ready.row(self.cpu2Process_text))
                self.signal_list_ready_del.emit(self.cpu2Process)
                # 该进程进入CPU1中运行
                # self.textEdit_CPU2.setStyleSheet("backgroud:red")
                self.signal_CPU2_setStyleSheet.emit("background:red")
                # self.textEdit_CPU2.setText("进程号：" + self.cpu2Process_text.split(",")[0])
                self.signal_CPU2_setText.emit("进程号：" + self.cpu2Process_text.split(",")[0])



            #模拟时间片-1
            self.sleep(1)

            if (self.cpu1Process_text != ""):
                '''
                开始执行模拟运行操作
                1。优先级减去1
                2。进程所需时间减1
                3。判断该进程是不是进行完了，
                如果没进行完，就重新放入就绪队列里的最后一个
                如果进行完了，就开始释放内存,执行内存管理模块
                '''
                cpu1PCB_Info = self.cpu1Process_text.split(",")
                #1.优先级减一,利用三元表达式计算优先级减一，最低值是1
                cpu1PCB_Info[2] = str((int(cpu1PCB_Info[2]) - 1)) if (int(cpu1PCB_Info[2]) - 1)>0 else str(1)
                #2.所需时间-1
                cpu1PCB_Info[1] = str(int(cpu1PCB_Info[1]) - 1)

                #构造出来执行完的PCB
                rdPCB = PCB(cpu1PCB_Info[0], cpu1PCB_Info[1], cpu1PCB_Info[2], cpu1PCB_Info[3], cpu1PCB_Info[4])

                #3.判断进程是不是进行完了
                if(cpu1PCB_Info[1]=="0"):
                    #说明该进程已经执行完了,
                    #1。释放内存
                    #2。放入到完成队列中
                    self.memory_recovery(cpu1PCB_Info)
                    #减少当前道数
                    self.nowdao = self.nowdao-1
                    # self.listWidget_finish.addItem(str(rdPCB))
                    self.signal_list_finish_add_fortext.emit(str(rdPCB))
                else:
                    #说明该进程还是没有执行完,要重新进入就绪队列中
                    # self.listWidget_ready.addItem(str(rdPCB))
                    self.signal_list_ready_add_fortext.emit(str(rdPCB))

                # CPU1处理完成，CPU1恢复原状
                # self.textEdit_CPU1.setText("")
                self.signal_CPU1_setText.emit("")
                # self.textEdit_CPU1.setStyleSheet("backgroud:white")
                self.signal_CPU1_setStyleSheet.emit("background:white")

            if (self.cpu2Process_text != ""):
                '''
                开始执行模拟运行操作
                1。优先级减去1
                2。进程所需时间减1
                3。判断该进程是不是进行完了，
                如果没进行完，就重新放入就绪队列里的最后一个
                如果进行完了，就开始释放内存,执行内存管理模块
                '''
                cpu2PCB_Info = self.cpu2Process_text.split(",")
                # 1.优先级减一,利用三元表达式计算优先级减一，最低值是1
                cpu2PCB_Info[2] = str((int(cpu2PCB_Info[2]) - 1)) if (int(cpu2PCB_Info[2]) - 1) > 0 else str(1)
                # 2.所需时间-1
                cpu2PCB_Info[1] = str(int(cpu2PCB_Info[1]) - 1)

                # 构造出来执行完的PCB
                rdPCB = PCB(cpu2PCB_Info[0], cpu2PCB_Info[1], cpu2PCB_Info[2], cpu2PCB_Info[3], cpu2PCB_Info[4])

                # 3.判断进程是不是进行完了
                if (cpu2PCB_Info[1] == "0"):
                    # 说明该进程已经执行完了,
                    # 1。释放内存
                    # 2。放入到完成队列中
                    self.memory_recovery(cpu2PCB_Info)
                    self.nowdao = self.nowdao - 1
                    # self.listWidget_finish.addItem(str(rdPCB))
                    self.signal_list_finish_add_fortext.emit(str(rdPCB))
                else:
                    # 说明该进程还是没有执行完,要重新进入就绪队列中
                    # self.listWidget_ready.addItem(str(rdPCB))
                    self.signal_list_ready_add_fortext.emit(str(rdPCB))

                # CPU2处理完成，CPU2恢复原状
                # self.textEdit_CPU2.setText("")
                self.signal_CPU2_setText.emit("")
                # self.textEdit_CPU2.setStyleSheet("backgroud:white")
                self.signal_CPU2_setStyleSheet.emit("background:white")

            count = 0
            r = 0
            while(r < len(self.memory)):
                while (self.memory[r].text()=="未使用"):
                    count = count +1
                    r = r+1
                    if (r == 40) :
                        break
                self.record[r - count] = r - 1
                count = 0
                r = r+1

            self.sleep(1)

    '''
    判断QListWiget是否为空函数模块
    '''
    def QListIsEmpty(self,ListWidget):
        if(ListWidget.item(0)==None):
            return True
        else:
            return False

    def QListIsNotEmpty(self,ListWidget):
        if(ListWidget.item(0)==None):
            return False
        else:
            return True


    '''
    内存分配模块
    '''
    def memory_alloc(self,PCB_text):
        self.totalmemory +=int(PCB_text[4])
        canput = False
        if (self.totalmemory <= len(self.memory) - 4) :
            x = 0
            while (x<len(self.memory)):
                if ((self.record[x]-x+1) >= int(PCB_text[4])) :
                    canput=True
                    temp=self.record[x]
                    for y in range(x,x+int(PCB_text[4])):
                        # self.memory[y].setBackground(QBrush(QColor(250,0,0)))
                        self.signal_list_memory_setBackground.emit(QBrush(QColor(250,0,0)),y)
                        # self.memory[y].setText(PCB_text[0])
                        self.signal_list_memory_setText.emit(PCB_text[0],y)
                        self.record[y]=-1
                    if (x+int(PCB_text[4]) <= len(self.memory)) :
                        print(x+"-"+(x+int(PCB_text[4])-1)+"被占用")
                        if ((x+int(PCB_text[4])) <= 39) :
                            self.record[x+int(PCB_text[4])]=temp
                            print(x+int(PCB_text[4])+"-"+temp+"为空闲内存")
                    print("解挂成功" )
                    break
                else :
                    x = self.record[x] - 1
        return canput

    '''
    内存释放模块
    '''
    def memory_recovery(self,PCB_text):
        self.totalmemory = self.totalmemory - int(PCB_text[4])
        havechange = False

        for x in range(len(self.memory)):
            #开始遍历寻找将要释放的PCB的起止地址
            if(self.memory[x].text()==PCB_text[0]):
                if( bool(1 - havechange)):
                    #找到了
                    # self.memory[x].setText("未使用")
                    print("释放内存"+str(x))
                    self.signal_list_memory_setText.emit("未使用",x)
                    # self.memory[x].setBackground(QBrush(QColor(250,250,250)))
                    self.signal_list_memory_setBackground.emit(QBrush(QColor(211,211,211)),x)
                    self.record[x] = self.record[x]+ int(PCB_text[4])
                    # 先考虑不能进行区块合并的
                    # 如果此块地址是0号或者是大于0的地址并且前面的哪块地址是被占用了的情况
                    if (x == 0 or ((x - 1) >= 0 and self.memory[x-1].text()!="未使用")):
                    # 如果这块地址是第39号地址，即最后一个地址或者这个进程的尾地址的后面是小于内存总地址并且该尾地址的后面哪块地址被占用了，那就不用进行内存合并了
                        if (x == 39 or (1 + self.record[x] < len(self.memory) and self.memory[1+self.record[x]].text()!= "未使用")):
                            self.record[x]=self.record[x] # 不用修改
                         #如果这个进程的尾地址的后面哪块内存小于尺寸并且这块地址是未被占用的内存地址，就要进行合并
                        elif ((1 + self.record[x]) < len(self.memory) and self.memory[1 + self.record[x]].text()=="未使用"):
                             #开始遍历合并
                            z = self.record[x]+1
                            print("z:"+str(z))
                            print("self.record[x]"+str(self.record[x]))
                            while (self.memory[z].text()=="未使用") :
                                z = z+1
                                if(z == 40):
                                    break
                            self.record[x] = z - 1
                            self.record[x] = self.record[1 + self.record[x]]
                            if (1 + self.record[x] < len(self.memory)):
                                self.record[1 + self.record[x]] = 0
                    # 如果大于0的地址并且前面的哪块地址是没有被占用了的，首先考虑和上面的合并
                    elif ((x - 1) >= 0 and self.memory[x - 1].text()=="未使用") :
                        z = x-1
                        while (z >= 0 and self.memory[z].text()=="未使用") :
                            z = z-1
                            if (z == 0) :
                                break
                        if (1 + self.record[x] < len(self.memory) and self.memory[1 + self.record[x]].text()== "未使用") :
                            self.record[z+1]=self.record[x]
                            # print((z+1)+"-"+self.record[x]+"为空闲内存")
                            self.record[x]=0
                        elif (1+self.record[x] < len(self.memory) and self.memory[1+self.record[x]].text()=="未使用") :
                            self.record[z+1]=self.record[1+self.record[x]]
                            # print((z+1)+"-"+self.record[z+1]+"为空闲内存")
                    havechange =True
                #给这个
                # self.memory[x].setBackground(QBrush(QColor(250,250,250)))
                self.signal_list_memory_setBackground.emit(QBrush(QColor(211,211,211)),x)
                # self.memory[x].setText("未使用")
                self.signal_list_memory_setText.emit("未使用",x)
                self.record[x] = 0


    def setLabelBreak(self,label):
        label.setStyleSheet("color:break")

    def setTimer(self):
        # self.Timer()
        pass

    def stopTimer(self):
        self.time.stop()



if __name__ == '__main__':

     app = QApplication(sys.argv)
     myloginWindow = QMainWindow()
     myUi = Ui_Form()
     myUi.setupUi(myloginWindow)
     if(myUi.listWidget_waiting.item(0)==None):
         print("chengg1")
     # myUi.setData(datas)
     myloginWindow.show()
     sys.exit(app.exec_())

